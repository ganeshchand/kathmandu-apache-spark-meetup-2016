// Databricks notebook source exported at Fri, 29 Jan 2016 21:29:26 UTC
import scala.collection.mutable.Map
import java.util.concurrent.{Executors}
import scala.collection.mutable.Map
import scala.util.matching.Regex
import scala.collection.mutable

/**
  * Created by jules on 1/29/16.
  * Simple class that implements runnable that will be part of the Executor pool of threads
  */
class DeviceIoTGenerators(range :Range) extends Runnable{

  val this.range = range
  var deviceMap: List[mutable.Map[String, String]] = List()
  var done: Boolean = false
  var thrName = ""

  def run: Unit = {

    thrName = Thread.currentThread().getName()
    println("Generating Devices info in " + thrName)
    deviceMap = DeviceProvision.getDeviceBatch(this.range)
    done = true
  }

  def isDone(): Boolean = return done
  def getDeviceBatches(): List[mutable.Map[String, String]] = return deviceMap
}

/**
  * Simple illustration of of using Maps, Singleton Objects, and threads defined in a package as well as usage of
  * collection filters and foreach methods on collections.
  */

object TestIotDevice {
  /**
    * Filter each device map where the k/v satisfy a predicate
    * @param elem Map[String, String]
    * @param k key in the Map
    * @param v value to satisfy
    * @return return true or false
    */
  def filterByKey(elem: scala.collection.mutable.Map[String, String], k:String, v: Int): Boolean = {
    val value:Int = elem.get(k).get.toInt
    return (value >= v)
  }

  /**
    * Filter each device map where the device_name key satisfies the regex pattern
    * @param elem Map[String, String]
    * @param pattern Regex that matches the device pattern
    * @return true or false
    */
  def filterByDevicePattern(elem: scala.collection.mutable.Map[String, String], pattern:scala.util.matching.Regex): Boolean = {
    val value:String = elem.get("device_name").get
    return (pattern.findFirstIn(value) != None)

  }
}

/**
  * Created by jules on 1/29/16.
  * In this example, I use an Executor Service with a pool threads to generate devices information concurrently. Not only it's an illustration
  * of Scala expressive, succinct, and declarative way of programming, it shows the power of its functional programming.
  *
  * Note how Collection.foreach() methods are used in List collection to submit jobs, to iterate over each List of Maps, and to print each
  * device Map. You can't help but admire the tightness of its API.
  *
  * Simple few lines of Scala.
  */
object DeviceIoTExecutor {

  /**
    * Using the foreach method of the List or Collection, print each device Map. In fact, this method
    * could be insert device data into an NoSQL or publish onto to a messaging system like Kafka.
    *
    * Also, note how filters are used from a previous Singleton instance, to create a a filtered
    * collection depending on the predicate
    * @param elem
    */
  def processMap(elem: List[scala.collection.mutable.Map[String, String]], thrName: String): Unit = {
    println("Processing each device map in the List generated by thread " + thrName)
    elem.foreach(println(_))
    //filter and create a new batch where the temperature is >= 30
    val filteredBatch: List[Map[String, String]] = elem.filter(TestIotDevice.filterByKey(_, "temp", 30))
    printf("%d Devices found where temperature is greater than or equal to %d\n", filteredBatch.length, 30)
    filteredBatch.foreach(println(_))
    //filter and create a new batch where the humidity is >=65
    val filteredBatch2: List[Map[String, String]] = elem.filter(TestIotDevice.filterByKey(_, "humidity", 65))
    printf("%d Devices found where humidity is greater than or equal to %d\n", filteredBatch2.length, 65)
    filteredBatch2.foreach(println(_))
  }
}
  
/**
	* This example illustrates how to use a Singleton scala object with the same names as the class object, within the
	* same file. Note that as Singleton object, it can be use outside this class as well.
	*/
object DeviceProvision {

	val author = "Jules S. Damji"
	val what = "Learning Scala!"
	val choice = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	val rnd = new util.Random()

	/**
		* Get a randome from within the specifed range
		* @param from
		* @param to
		* @return generated number
    */
	def getRandomNumber(from: Int, to: Int): Int = {
		return from + rnd.nextInt(Math.abs(to - from))
	}

	/**
		* Generate a random zipcode between two legal ranges
		* @return generated zip code
    */
	def getZipCode(): Int = {
		return getRandomNumber(94538, 97107)
	}

	/**
		* Generate a random X coordinate
		* @return generated x coordinate
    */
	def getX(): Int = {
		val x: Int = getRandomNumber(10, 100)
		return x
	}

	/**
		* Generate a random Y coordinate
		* @return generated Y coordinate
    */
	def getY(): Int = {
		val y: Int = getRandomNumber(10, 100)
		return y
	}

	/**
		* Generate random humidity between two numbers: min and max
		* @return generated humidity
    */
	def getHumidity(): Int = {
		return getRandomNumber(25, 100)
	}

	/**
		* Generate a random temperature between two min and max
		* @return generated temperature
    */
	def getTemperature(): Int = {
		return getRandomNumber(10, 35)
	}

	/**
		* Generate a randome string from with an alphate range between min and max len
		* @param minLen
		* @param maxLen
		* @return
    */
	def getRandomString(minLen: Int = 5, maxLen: Int = 10): String = {
		val len = rnd.nextInt(1 + maxLen - minLen) + minLen
		val sb = new StringBuilder(len)
		for (_ <- 0 until len) {
			sb.append(choice.charAt(rnd.nextInt(choice.length())))
		}
		return sb.toString
	}

	/**
		* Create a Map of device information
		* @param dev device name
		* @param id device id
		* @return Map[String, String]
    */
	def createDeviceData(dev: String, id: Int): scala.collection.mutable.Map[String, String] = {
		var dmap = scala.collection.mutable.Map[String, String]()
		val temp = getTemperature().toString
		val humidity = getHumidity().toString
		val zip = getZipCode().toString
		// create json of the format:
		// {'device_id': id, 'device_name': d, 'timestamp': ts, 'temp': temp, 'scale': 'Celius', "lat": x, "long": y, 'zipcode': zipcode, 'humidity': humidity}
		val timestamp: Long = System.currentTimeMillis / 1000
		dmap.put("device_name", dev)
		dmap.put("device_id", id.toString)
		dmap.put("timestamp", timestamp.toString)
		dmap.put("temp", temp)
		dmap.put("scale", "Celcius")
		dmap.put("lat", getX().toString)
		dmap.put("long", getY().toString)
		dmap.put("zipcode", zip)
		dmap.put("humidity", humidity)
		return dmap
	}

	/**
		* Create a collection, List, of Map[String, String] for range of device id
		* @param range of device ids
		* @return List[Map[String, String]]
    */
	def getDeviceBatch(range: Range): List[Map[String, String]] = {
		var batch: List[Map[String, String]] = List()
		var id: Int = range.start
		var device: String = ""
		for (id <- range.start to range.end) {
			if (id % 2 == 0) {
				device = "sensor-pad-" + id.toString + getRandomString()
			} else if (id % 3 == 0) {
				device = "device-mac-" + id.toString + getRandomString()
			} else if (id % 5 == 0) {
				device = "therm-stick-" + id.toString + getRandomString()
			} else {
				device = "meter-gauge-" + id.toString + getRandomString()
			}
			Thread.sleep(10)
			val djson = createDeviceData(device, id)
			batch = batch.::(djson)
		}
		return batch.reverse
	}

	/**
		* Generate a luv message :)
		* @param message
    */
	def myPrint(message: String): Unit = {
		val luv = "...And Luving it!"
		print(message)
		println(author + " is " + what + luv)
	}
}

    val ndevices = 120
    // for easy of creating equal batches, let's force the device number to be a multiple of three
    if (ndevices % 3 != 0) {
      println("Number of devices must be multiple of 3.")
      System.exit(1)
    }

    DeviceProvision.myPrint("Hello Scala World ")
    //create a pool of three threads, assuming we have three cores
    val cores = 3
    val pool = Executors.newFixedThreadPool(cores)
    val multiple = ndevices / 3
    var devGenerators: List[DeviceIoTGenerators] = List()
    //create list of three DeviceGenerator Runnable(s), each with its begin..end range of device numbers
    devGenerators = devGenerators.::(new DeviceIoTGenerators(1 until multiple))
    devGenerators = devGenerators.::(new DeviceIoTGenerators(multiple + 1 until 2 * multiple))
    devGenerators = devGenerators.::(new DeviceIoTGenerators((2 * multiple) + 1 until 3 * multiple))
    // Using foreach method on the list, submit each runnable to the executor service thread pool
    devGenerators.foreach(pool.submit(_))
    // let each Runnable finish in the pool; we could use an elaborate LatchCountDown if we wanted to , but since
    // this is a simple case, where the thread are unlikely to block or delay, a minor Sleep shall suffice.
    Thread.sleep(3000)
    // reverse the order of the List, since in Scala, for efficiency, Lists are appended to the front.
    devGenerators = devGenerators.reverse
    // Using foreach method, once again, iterate for each List[Map[String, String]] generated by each Runnable
    devGenerators.foreach(e => DeviceIoTExecutor.processMap(e.getDeviceBatches(), e.thrName ))
    println("Finished...")

// COMMAND ----------


